# Deep Composition
大家好，今天我要分享的是SIGGRAPH2017 的一篇文章，题目是DCULA
文章作者是Tom大夫，右图是他在Pixar的办公室。1984年他写了一篇关于compositing的经典论文中。在1984年的这篇论文中，Tom提出了将两幅有透明度（也叫alpha通道的）的图片，组合在一起方法。例如左图是将一个半透明的正方形和一个半透明的圆形Compositing的结果。图片的透明度，现在也就是阿尔法通道。中间的图来自在电影《星球大战》，也是用alpha compositing得到的。

现如今，渲染出来的电影场景，基本上都是Compositing组成的。因为不同的物体，会采用不同的方法。例如，下图里，烟雾里面有一群马。烟雾的渲染方法，和马群的渲染方法，就不一样。将场景分解为几部分来渲染，效率也更高。例如，当我们修改了马的模型，就不用重新渲染烟雾部分。

现在的Compositing比alpha compositing更复杂，例如图中的这团烟雾，每个像素点上，不同的深度，有不同的颜色值。是一种体素图。做compositing的时候，也是对这种带深度信息的图片做Compositing，也就成为Deep compositing。

这在工业中非常有用，相关技术得过3个奥斯卡技术奖。据渲染霍比特人的公司说，Deep Compositing是他们pipeline里面不过会关掉的一部分。并且这种技术在OpenEXR这种图像文件格式中得到支持。

下面这张图就是DeepCompositing得到的。这张图里面有一个人站在一个球里面，是用一个人和一个球DeepCompositing得到的。

为了做DeepCompositing，我们先介绍一下当没有深度信息的时候怎么做AlphaCompositing。我们定义一个像素上的值表达为
大A等于小a和阿尔法，其中小a是颜色值，由RGB三个通道构成，alpha代表能挡住多少光的比例。alpha=0代表透明，alpha=1代表完全不透明
下面我们来看一下A覆盖在B上面时，颜色值应该是怎么样的呢？我们假设，光在穿过物体的时候，按照alpha的比例被吸收，也就是说B发出的光线，只有1-alpha的比例可以透过物体。这里小a其实表示的是原来物体的颜色乘以alpha

在做deepCompositing，首先，我们需要考虑如何表示我们的Volumetric Image
用体素来表示的代价是非常高的。如果我们假设在像素点背后，不同的深度，可以分成多个区间，区间内部，pixel value是相同的。

deepCompositing要做的事情，就是将两个区间上的像素颜色做一个合并。之所以可以做这样的合并，其实蕴含了一个假设，我们假设区间透光的性能是均匀的，也就是说，如果我们将区间分成长度相等的两段，那么它们应当各自透过50%原来区间透过的光。

基于这个假设，所以compositing的总体算法流程是，先将原来的区间分段，lambda和miu各自表达子区间想对于原区间的相对长度。然后计算各个子区间的pixel value，最后合并所有的pixel value起来。

子区间的pixel value的计算方法是，前面我们假设挡住的光与长度成正比，换句话说，区间，是由很多半透明的小块组成的，那么这个区间的pixel value也就应当等于这些小块一层覆盖一层的最终结果。这样可以推导出一个指数函数的公式。虽然n是整数，但用整数计算出来的公式可以推广到相对长度lambda上。

类似地，merge两个区间时，我们也认为A和B的子区间共同占据了该公共区间，可以认为光学性能分别为为A，B的半透明块交替分布在公共区间上。并且A merge B应该等于B merge A，要做到这个效果，一种简单的方法，就是让小区间的数量趋近于无穷，这样就不会有先后顺序之分了。通过科学计算的库SymPy，可以推导得到A Merge B 这个比较复杂的公式。

到目前为止，目前我们推导出来的Deep Compositing公式比较复杂。很难分析。但对于做工业界做Deep Compositing的小圈子里面的人来说，这些公式他们都是知道的。Tom Duff发表的这篇SIGGRAPH2017年的论文，就是用一些数学工具把这个两个公式写得更漂亮了一些，也更容易分析。首先借助数学，我们能找到一对映射和逆映射。这里的对数映射将pixel value映射为另一个用方括号表示的向量。而指数映射将方括号的向量映射回pixel value。

借助这两个映射，我们可以将split和merge的操作写得非常简洁。原来的空间里面A叠加在B上面是比较难分析的。
现在可以在logA和logB的空间里面去分析它们。线性代数的工具都可以用上。

采取了这种新的视角以后，例如，我们可以在logA和logB的空间里面对他们做线性插值，并且，这样的插值，对于split函数有一种不变性，就是先对A，B插值，再split跟先split再插值，结果是一样的。






















