今天，我要讲的是怎么用GJK算法做碰撞检测。

GJK算法是一种计算两个凸集中的点，之间的最小距离的算法。例如左图中的两个集合之间的最小距离是1,右图中两个集合相交，最小距离是0。

为了让记号更加简洁，我们引入一些新的记号。定义C=A+(-B)。这样，AB之间的最小距离就转化为了集合C中的点到原点的最小距离。显然，我们不能直接遍历整个集合C。

GJK算法的思路是在集合C中找一个（三角形/四面体/线段/点）（统称为单纯形），尽可能地贴近甚至说是包住原点，如果找到一个能包住原点的单纯形，那么最小距离就是0。如果包不住，那么原点到单纯形的距离就是原点到集合C的距离的近似。大家可以看一下，这附图，原点到红色集合的距离，就等于原点到单纯形/三角形BFD的距离。

为了让单纯形不断地向原点靠近。我们要让它往原点运动。

为了找到这样的三角形，我们需要先引入一个概念叫做，支撑，support。给定一个集合A和一个方向d，定义support为集合A在d方向上的最远点。例如在图中，给定了集合A，和方向d，B点就是support。

有了这个定义以后，为了简单起见，我们先讲一下，用GJK的算法怎么做碰撞检测。
首先随机选取一个方向，找到一个支撑点。
将支撑点作为单纯形，沿着支撑点指向到原点的方向，搜索新的支撑点，如果在该方向上，新的支撑点没有超过原点的话，那么集合C就不包含原点。因为这个算法是在做碰撞检测，所以这里就可以直接返回了。（如果原点在集合内，那么把它们投影到在任何方向上，原点的投影都应该位于集合的投影内。）

否则的话，我们将新的支撑点加入到单纯形中，然后计算这个单纯形应该往哪个区域运动。

在讨论如何更新单纯形之前，我们先来看一下怎么找支撑。对于多边形或者多面体，这个问题比较简单。闵可夫斯基和的支撑可以由原来的集合的支撑直接计算得到。
对于用方程来表达的图形，例如圆，也可以有对应的公式计算。总之只要是有办法快速计算支撑的图形，都可以使用GJK算法。

好，下面讲如何更新单纯形。我们想要让单纯形往原点运动。但具体往哪个方向运动呢？大家看这附图，可以看出，一个单纯形把它周围的空间分成了几部分。包括单纯形的内部，边的领域，点的领域。这些区域叫做单纯形的Voronoi区域。简单的做法，需要遍历单纯形的Voronoi区域，对于三角形来说，这样的区域有7个。但更聪明的做法是利用之前遍历的信息。

另外判断点在不再


